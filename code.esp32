/*
 * Sistem Monitoring Pompa Air Sumur Bor Bertenaga Surya
 * Berbasis Fuzzy Logic dan IoT (Blynk)
 * 
 * Deskripsi: Sistem otomatis untuk mengontrol pompa air berdasarkan
 * kondisi tegangan dan arus dari panel surya dan baterai menggunakan
 * logika fuzzy dan monitoring real-time melalui aplikasi Blynk
 * 
 * Komponen:
 * - ESP32 NodeMCU
 * - Sensor Tegangan
 * - Sensor Arus (ACS712)
 * - Relay 4 Channel
 * - Panel Surya
 * - Pompa Air DC
 * - Baterai
 */

#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <SimpleTimer.h>

// Kredensial Blynk - GANTI DENGAN KREDENSIAL ANDA
#define BLYNK_TEMPLATE_ID "TMPL_ID_ANDA"
#define BLYNK_DEVICE_NAME "Monitor Pompa Surya"
#define BLYNK_AUTH_TOKEN "TOKEN_BLYNK_ANDA"
#define BLYNK_PRINT Serial

// Kredensial WiFi - GANTI DENGAN KREDENSIAL ANDA
const char* ssid = "NAMA_WIFI_ANDA";
const char* password = "PASSWORD_WIFI_ANDA";

// Pin Konfigurasi ESP32
#define PIN_SENSOR_TEGANGAN_SURYA 34      // Pin ADC untuk sensor tegangan panel surya
#define PIN_SENSOR_ARUS_SURYA 35          // Pin ADC untuk sensor arus panel surya
#define PIN_SENSOR_TEGANGAN_BATERAI 32    // Pin ADC untuk sensor tegangan baterai
#define PIN_SENSOR_ARUS_BATERAI 33        // Pin ADC untuk sensor arus baterai
#define PIN_RELAY_POMPA 2                 // Pin kontrol relay pompa
#define PIN_LED_STATUS 4                  // Pin LED status sistem

// Konstanta Kalibrasi Sensor
#define RASIO_PEMBAGI_TEGANGAN 11.0       // Rasio pembagi tegangan (R1+R2)/R2
#define SENSITIVITAS_SENSOR_ARUS 0.1      // 100mV/A untuk ACS712-20A
#define OFFSET_SENSOR_ARUS 2.5            // Offset 2.5V pada 0A
#define RESOLUSI_ADC 4095.0               // ADC 12-bit
#define TEGANGAN_REFERENSI_ADC 3.3        // Tegangan referensi ADC

// Virtual Pin Blynk
#define VPIN_TEGANGAN_SURYA V0
#define VPIN_ARUS_SURYA V1
#define VPIN_TEGANGAN_BATERAI V2
#define VPIN_ARUS_BATERAI V3
#define VPIN_STATUS_POMPA V4
#define VPIN_DAYA_SURYA V5
#define VPIN_DAYA_BATERAI V6
#define VPIN_KONTROL_MANUAL V7

// Struktur Data Input Fuzzy
struct InputFuzzy {
  float tegangan_surya;
  float arus_surya;
  float tegangan_baterai;
  float arus_baterai;
  float daya_surya;
  float daya_baterai;
};

// Struktur Data Output Fuzzy
struct OutputFuzzy {
  bool status_pompa;
  float tingkat_kepercayaan;
  String alasan_keputusan;
};

// Struktur Fungsi Keanggotaan
struct FungsiKeanggotaan {
  float rendah;
  float sedang;
  float tinggi;
};

// Variabel Global
InputFuzzy sensor_data;
OutputFuzzy hasil_fuzzy;
SimpleTimer timer;
bool sistem_terinisialisasi = false;
bool mode_manual = false;
unsigned long waktu_baca_sensor_terakhir = 0;
const unsigned long INTERVAL_BACA_SENSOR = 1000; // 1 detik

// Statistik sistem
unsigned long total_waktu_hidup_pompa = 0;
unsigned long waktu_mulai_pompa = 0;
bool pompa_sedang_hidup = false;
float konsumsi_energi_total = 0;

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("=== SISTEM MONITORING POMPA AIR TENAGA SURYA ===");
  Serial.println("Menggunakan Fuzzy Logic dan IoT");
  Serial.println("Menginisialisasi sistem...");
  
  // Inisialisasi pin
  pinMode(PIN_RELAY_POMPA, OUTPUT);
  pinMode(PIN_LED_STATUS, OUTPUT);
  digitalWrite(PIN_RELAY_POMPA, LOW);  // Pompa OFF awal
  digitalWrite(PIN_LED_STATUS, LOW);
  
  // Inisialisasi sensor ADC
  analogReadResolution(12); // Set resolusi ADC 12-bit
  
  // Koneksi WiFi
  inisialisasiWiFi();
  
  // Inisialisasi Blynk
  if (WiFi.status() == WL_CONNECTED) {
    Blynk.begin(BLYNK_AUTH_TOKEN, ssid, password);
    Serial.println("Blynk berhasil diinisialisasi");
  }
  
  // Setup timer untuk membaca sensor dan mengirim data
  timer.setInterval(2000L, kirimDataSensor);      // Kirim data setiap 2 detik
  timer.setInterval(1000L, prosesLogicFuzzy);     // Proses fuzzy setiap 1 detik
  timer.setInterval(30000L, kirimStatistik);      // Kirim statistik setiap 30 detik
  
  // Inisialisasi selesai
  sistem_terinisialisasi = true;
  digitalWrite(PIN_LED_STATUS, HIGH);
  
  Serial.println("Sistem siap beroperasi!");
  Serial.println("=====================================");
}

void loop() {
  // Jalankan Blynk
  if (WiFi.status() == WL_CONNECTED) {
    Blynk.run();
  }
  
  // Jalankan timer
  timer.run();
  
  // Baca sensor secara berkala
  if (millis() - waktu_baca_sensor_terakhir >= INTERVAL_BACA_SENSOR) {
    bacaSensorSemua();
    waktu_baca_sensor_terakhir = millis();
  }
  
  // Cek koneksi WiFi dan reconnect jika perlu
  cekKoneksiWiFi();
  
  delay(100); // Delay kecil untuk stabilitas
}

// Fungsi Inisialisasi WiFi
void inisialisasiWiFi() {
  WiFi.begin(ssid, password);
  Serial.print("Menghubungkan ke WiFi");
  
  int percobaan_wifi = 0;
  while (WiFi.status() != WL_CONNECTED && percobaan_wifi < 20) {
    delay(500);
    Serial.print(".");
    percobaan_wifi++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.print("WiFi terhubung! IP: ");
    Serial.println(WiFi.localIP());
    digitalWrite(PIN_LED_STATUS, HIGH);
  } else {
    Serial.println();
    Serial.println("Koneksi WiFi gagal! Berjalan dalam mode offline.");
  }
}

// Fungsi untuk membaca semua sensor
void bacaSensorSemua() {
  // Baca sensor panel surya
  sensor_data.tegangan_surya = bacaSensorTegangan(PIN_SENSOR_TEGANGAN_SURYA);
  sensor_data.arus_surya = bacaSensorArus(PIN_SENSOR_ARUS_SURYA);
  sensor_data.daya_surya = sensor_data.tegangan_surya * sensor_data.arus_surya;
  
  // Baca sensor baterai
  sensor_data.tegangan_baterai = bacaSensorTegangan(PIN_SENSOR_TEGANGAN_BATERAI);
  sensor_data.arus_baterai = bacaSensorArus(PIN_SENSOR_ARUS_BATERAI);
  sensor_data.daya_baterai = sensor_data.tegangan_baterai * sensor_data.arus_baterai;
  
  // Debug output
  Serial.print("Panel Surya - V: ");
  Serial.print(sensor_data.tegangan_surya, 2);
  Serial.print("V, I: ");
  Serial.print(sensor_data.arus_surya, 2);
  Serial.print("A, P: ");
  Serial.print(sensor_data.daya_surya, 2);
  Serial.println("W");
  
  Serial.print("Baterai - V: ");
  Serial.print(sensor_data.tegangan_baterai, 2);
  Serial.print("V, I: ");
  Serial.print(sensor_data.arus_baterai, 2);
  Serial.print("A, P: ");
  Serial.print(sensor_data.daya_baterai, 2);
  Serial.println("W");
}

// Fungsi membaca sensor tegangan
float bacaSensorTegangan(int pin) {
  int nilai_adc = analogRead(pin);
  float tegangan_adc = (nilai_adc / RESOLUSI_ADC) * TEGANGAN_REFERENSI_ADC;
  float tegangan_sebenarnya = tegangan_adc * RASIO_PEMBAGI_TEGANGAN;
  return tegangan_sebenarnya;
}

// Fungsi membaca sensor arus
float bacaSensorArus(int pin) {
  int nilai_adc = analogRead(pin);
  float tegangan_sensor = (nilai_adc / RESOLUSI_ADC) * TEGANGAN_REFERENSI_ADC;
  float arus = (tegangan_sensor - OFFSET_SENSOR_ARUS) / SENSITIVITAS_SENSOR_ARUS;
  return abs(arus); // Return nilai absolut untuk menghindari nilai negatif
}

// Fungsi Logika Fuzzy
void prosesLogicFuzzy() {
  if (!mode_manual) {
    // Proses fuzzifikasi
    FungsiKeanggotaan tegangan_surya_fuzzy = fuzzifikasiTegangan(sensor_data.tegangan_surya);
    FungsiKeanggotaan arus_surya_fuzzy = fuzzifikasiArus(sensor_data.arus_surya);
    FungsiKeanggotaan tegangan_baterai_fuzzy = fuzzifikasiTegangan(sensor_data.tegangan_baterai);
    FungsiKeanggotaan arus_baterai_fuzzy = fuzzifikasiArus(sensor_data.arus_baterai);
    
    // Evaluasi rule fuzzy dan ambil keputusan
    hasil_fuzzy = evaluasiRuleFuzzy(tegangan_surya_fuzzy, arus_surya_fuzzy, 
                                   tegangan_baterai_fuzzy, arus_baterai_fuzzy);
    
    // Kontrol pompa berdasarkan hasil fuzzy
    kontrolPompa(hasil_fuzzy.status_pompa);
    
    // Debug output
    Serial.print("Hasil Fuzzy - Status Pompa: ");
    Serial.print(hasil_fuzzy.status_pompa ? "HIDUP" : "MATI");
    Serial.print(", Kepercayaan: ");
    Serial.print(hasil_fuzzy.tingkat_kepercayaan, 2);
    Serial.print(", Alasan: ");
    Serial.println(hasil_fuzzy.alasan_keputusan);
  }
}

// Fungsi fuzzifikasi untuk tegangan
FungsiKeanggotaan fuzzifikasiTegangan(float tegangan) {
  FungsiKeanggotaan hasil;
  
  // Fungsi keanggotaan tegangan rendah (0-15V)
  if (tegangan <= 12.0) {
    hasil.rendah = 1.0;
  } else if (tegangan > 12.0 && tegangan < 15.0) {
    hasil.rendah = (15.0 - tegangan) / (15.0 - 12.0);
  } else {
    hasil.rendah = 0.0;
  }
  
  // Fungsi keanggotaan tegangan sedang (12-20V)
  if (tegangan <= 12.0 || tegangan >= 20.0) {
    hasil.sedang = 0.0;
  } else if (tegangan > 12.0 && tegangan <= 17.0) {
    hasil.sedang = (tegangan - 12.0) / (15.0 - 12.0);
  } else if (tegangan > 17.0 && tegangan < 20.0) {
    hasil.sedang = (20.0 - tegangan) / (20.0 - 17.0);
  }
  
  // Fungsi keanggotaan tegangan tinggi (17-24V)
  if (tegangan <= 17.0) {
    hasil.tinggi = 0.0;
  } else if (tegangan > 17.0 && tegangan < 20.0) {
    hasil.tinggi = (tegangan - 17.0) / (20.0 - 17.0);
  } else {
    hasil.tinggi = 1.0;
  }
  
  return hasil;
}

// Fungsi fuzzifikasi untuk arus
FungsiKeanggotaan fuzzifikasiArus(float arus) {
  FungsiKeanggotaan hasil;
  
  // Fungsi keanggotaan arus rendah (0-3A)
  if (arus <= 1.5) {
    hasil.rendah = 1.0;
  } else if (arus > 1.5 && arus < 3.0) {
    hasil.rendah = (3.0 - arus) / (3.0 - 1.5);
  } else {
    hasil.rendah = 0.0;
  }
  
  // Fungsi keanggotaan arus sedang (1.5-5A)
  if (arus <= 1.5 || arus >= 5.0) {
    hasil.sedang = 0.0;
  } else if (arus > 1.5 && arus <= 4.0) {
    hasil.sedang = (arus - 1.5) / (3.0 - 1.5);
  } else if (arus > 4.0 && arus < 5.0) {
    hasil.sedang = (5.0 - arus) / (5.0 - 4.0);
  }
  
  // Fungsi keanggotaan arus tinggi (4-10A)
  if (arus <= 4.0) {
    hasil.tinggi = 0.0;
  } else if (arus > 4.0 && arus < 5.0) {
    hasil.tinggi = (arus - 4.0) / (5.0 - 4.0);
  } else {
    hasil.tinggi = 1.0;
  }
  
  return hasil;
}

// Fungsi evaluasi rule fuzzy
OutputFuzzy evaluasiRuleFuzzy(FungsiKeanggotaan teg_surya, FungsiKeanggotaan arus_surya,
                              FungsiKeanggotaan teg_baterai, FungsiKeanggotaan arus_baterai) {
  OutputFuzzy hasil;
  float skor_hidup = 0.0;
  float skor_mati = 0.0;
  String alasan = "";
  
  // Rule 1-9: Evaluasi panel surya
  // Rule 5: Jika tegangan sedang DAN arus sedang maka pompa HIDUP
  float rule5 = min(teg_surya.sedang, arus_surya.sedang);
  skor_hidup = max(skor_hidup, rule5);
  
  // Rule 6: Jika tegangan sedang DAN arus tinggi maka pompa HIDUP  
  float rule6 = min(teg_surya.sedang, arus_surya.tinggi);
  skor_hidup = max(skor_hidup, rule6);
  
  // Rule 8: Jika tegangan tinggi DAN arus sedang maka pompa HIDUP
  float rule8 = min(teg_surya.tinggi, arus_surya.sedang);
  skor_hidup = max(skor_hidup, rule8);
  
  // Rule 9: Jika tegangan tinggi DAN arus tinggi maka pompa HIDUP
  float rule9 = min(teg_surya.tinggi, arus_surya.tinggi);
  skor_hidup = max(skor_hidup, rule9);
  
  // Rule untuk kondisi mati (rule 1,2,3,4,7)
  float rule1 = min(teg_surya.rendah, arus_surya.rendah);
  float rule2 = min(teg_surya.rendah, arus_surya.sedang);
  float rule3 = min(teg_surya.rendah, arus_surya.tinggi);
  float rule4 = min(teg_surya.sedang, arus_surya.rendah);
  float rule7 = min(teg_surya.tinggi, arus_surya.rendah);
  
  skor_mati = max({rule1, rule2, rule3, rule4, rule7});
  
  // Evaluasi baterai juga (rule 14,15,17,18 untuk hidup)
  float rule14 = min(teg_baterai.sedang, arus_baterai.sedang);
  float rule15 = min(teg_baterai.sedang, arus_baterai.tinggi);
  float rule17 = min(teg_baterai.tinggi, arus_baterai.sedang);
  float rule18 = min(teg_baterai.tinggi, arus_baterai.tinggi);
  
  float skor_hidup_baterai = max({rule14, rule15, rule17, rule18});
  
  // Gabungan keputusan: pompa hidup jika panel surya ATAU baterai mencukupi
  skor_hidup = max(skor_hidup, skor_hidup_baterai);
  
  // Ambil keputusan final
  if (skor_hidup > skor_mati) {
    hasil.status_pompa = true;
    hasil.tingkat_kepercayaan = skor_hidup;
    alasan = "Daya mencukupi";
  } else {
    hasil.status_pompa = false;
    hasil.tingkat_kepercayaan = skor_mati;
    alasan = "Daya tidak mencukupi";
  }
  
  // Tambahan keamanan: jika tegangan baterai terlalu rendah, paksa mati
  if (sensor_data.tegangan_baterai < 10.5) {
    hasil.status_pompa = false;
    alasan = "Baterai lemah - proteksi";
  }
  
  hasil.alasan_keputusan = alasan;
  return hasil;
}

// Fungsi kontrol pompa
void kontrolPompa(bool status) {
  static bool status_sebelumnya = false;
  
  if (status != status_sebelumnya) {
    if (status) {
      digitalWrite(PIN_RELAY_POMPA, HIGH);
      waktu_mulai_pompa = millis();
      pompa_sedang_hidup = true;
      Serial.println(">>> POMPA DIHIDUPKAN <<<");
    } else {
      digitalWrite(PIN_RELAY_POMPA, LOW);
      if (pompa_sedang_hidup) {
        total_waktu_hidup_pompa += (millis() - waktu_mulai_pompa);
        pompa_sedang_hidup = false;
      }
      Serial.println(">>> POMPA DIMATIKAN <<<");
    }
    status_sebelumnya = status;
  }
}

// Fungsi kirim data sensor ke Blynk
void kirimDataSensor() {
  if (WiFi.status() == WL_CONNECTED) {
    Blynk.virtualWrite(VPIN_TEGANGAN_SURYA, sensor_data.tegangan_surya);
    Blynk.virtualWrite(VPIN_ARUS_SURYA, sensor_data.arus_surya);
    Blynk.virtualWrite(VPIN_TEGANGAN_BATERAI, sensor_data.tegangan_baterai);
    Blynk.virtualWrite(VPIN_ARUS_BATERAI, sensor_data.arus_baterai);
    Blynk.virtualWrite(VPIN_STATUS_POMPA, hasil_fuzzy.status_pompa ? 1 : 0);
    Blynk.virtualWrite(VPIN_DAYA_SURYA, sensor_data.daya_surya);
    Blynk.virtualWrite(VPIN_DAYA_BATERAI, sensor_data.daya_baterai);
  }
}

// Fungsi kirim statistik sistem
void kirimStatistik() {
  if (WiFi.status() == WL_CONNECTED) {
    float efisiensi_panel = 0;
    if (sensor_data.daya_surya > 0) {
      efisiensi_panel = (sensor_data.daya_surya / 100) * 100; // Asumsi panel 100W
    }
    
    // Kirim data tambahan melalui terminal Blynk
    Blynk.virtualWrite(V10, String("Efisiensi Panel: ") + String(efisiensi_panel, 1) + "%");
    Blynk.virtualWrite(V11, String("Total Waktu Pompa: ") + String(total_waktu_hidup_pompa/1000) + "s");
  }
}

// Handler untuk kontrol manual dari Blynk
BLYNK_WRITE(VPIN_KONTROL_MANUAL) {
  int nilai = param.asInt();
  if (nilai == 1) {
    mode_manual = true;
    kontrolPompa(true);
    Serial.println("Mode manual: POMPA HIDUP");
  } else {
    mode_manual = false;
    Serial.println("Mode otomatis diaktifkan");
  }
}

// Fungsi cek koneksi WiFi
void cekKoneksiWiFi() {
  static unsigned long waktu_cek_terakhir = 0;
  
  if (millis() - waktu_cek_terakhir > 30000) { // Cek setiap 30 detik
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("WiFi terputus, mencoba reconnect...");
      WiFi.reconnect();
      digitalWrite(PIN_LED_STATUS, LOW);
    } else {
      digitalWrite(PIN_LED_STATUS, HIGH);
    }
    waktu_cek_terakhir = millis();
  }
}
